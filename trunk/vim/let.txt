	<<41>>
				    :help usr_41.txt

1 简介	*vim-script-intro* *script*
|&
let i = 1
while i < 5
    echo "count is" i
    let i += 1
endwhile

for i in range(1, 4)
  echo "count is" i
endfor
&|


2 变量
2.1 变量类型
	b:name		缓冲区的局部变量
	w:name		窗口的局部变量
	g:name		全局变量 (也用于函数中)
	v:name		Vim 预定义的变量
	s:name		脚本文件的局部变量   有错误 QQQQQ

|&
if !exists("w:call_count")
    let w:call_count = 0
endif
let w:call_count = w:call_count + 1
echo "called" w:call_count "times"
&|

2.2 删除变量
	unlet s:count
	unlet! s:count	若变量并不存在也不提示错误

NOTE:
当一个脚本结束时, 它使用的局部变量不会自动被删除. 下一次脚本被执行时, 旧的变量
值仍可被使用.
NOTE:
如果期待数值类型, Vim 自动把字符串转换为数值. 如果使用不以数位开始的字符串, 返
回的数值为零. 所以小心这种代码:
    ":if "true"
"这里 "true" 会被解读为零, 也就是假值!

2.3 字符串变量

2.3.1 ' 和 "
所有的字符在单引号内都保持其本来面目. 只有单引号本身例外: 输入两个你会得到一个
单引号. 因为反斜杠在其中也被作为其本身来对待, 你无法使用它来改变其后的字符的意
义. 

在双引号括起来的字符串中可以使用特殊字符. 这里有一些有用的例子:
	\t		<Tab>
	\n		<NL>, 换行
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, 退格
	\"		"
	\\		\, 反斜杠
	\<Esc>		<Esc>
	\<C-W>		CTRL-W



3. 表达式
3.1 表达式的使用方式
	$NAME		环境变量
	&name		选项
	@r		寄存器

NOTE:
    &name 这种形式可以被用来暂时改变一个选项的值. 例:
|&
:let save_ic = &ic
:set noic
:/The Start/,$delete
:let &ic = save_ic
&|

3.2 算术
	a + b		加
	a - b		减
	a * b		乘
	a / b		除
	a % b		余
	a ? b : c	如果 "a" 为真用 "b", 否则用 "c".
	a . b		把两个字符串连接起来. 例如:
|&
:echo "foo" . "bar"
&|


4. 条件语句
4.1 if
	:if {condition}
	   {statements}
	:endif

	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif

	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif
4.2 逻 辑 操 作
1)  对数值和字符串都有效:
	a == b		等于
	a != b		不等于
	a >  b		大于
	a >= b		大于等于
	a <  b		小于
	a <= b		小于等于
	(如果条件满足, 结果为 1, 否则为 0.)
2)  对于字符串来说还有两种操作:
	a =~ b		匹配
	a !~ b		不匹配

NOTE:
在做字符串比较时用到 'ignorecase' 选项. 如果你不希望使用该选项, 可以在比较时加
上 "#" 或 "?". "#" 表示大小写敏感; "?" 表示忽略大小写. 因此 "==?" 比较两字符串
是否相等, 不计大小写. "!~#" 检查一个模式是否被匹配, 同时也考虑大小写.
(SEE ALSO |expr-==|)

NOTE:
对数值和字符串都可以做逻辑操作
下面的例子将显示 "yes", 因为 "one" 看起来不像一个数值, 所以被转换为 0 了.
|&
:if 0 == "one"
:  echo "yes"
:endif
&|

|&
:let str = 'jj l.'
:if str =~ " "
:  echo "字符串包括空格"
:endif
:if str !~ '\.$'
:  echo "字符串不以句号结尾"
:endif
&|
NOTE: 在匹配模式中用单引号是很有用的. 因为匹配模式中通常有很多反斜杠, 而反斜杠
在双引号字符串中必须双写才有效.

4.3 循 环 详 述
	:continue		跳回 while 循环的开始; 继续循环
	:break			跳至 ":endwhile"; 循环结束


5. 执行一个表达式
:execute 命令可以执行一个表达式的结果
	:execute "tag " . tag_name
:normal  命令可以用来执行普通模式命令
	:normal gg=G
为了使 ":normal" 命令也可以带表达式, 可以把 ":execute" 与其连起来使用.
	:execute "normal " . normal_commands
如果你不想执行字符串, 而想执行它作为表达式计算的结果, 可以用 eval() 函数:
	:let optname = "path"
	:let optval = eval('&' . optname)
	    "&" 被加到 "path" 前面, 这样传给 eval() 的参数成为 "&path". 这时得
	    到的返回值就是 'path' 选项的值.
    等价于:
	:exe 'let optval = &' . optname


6. 使用函数
SEE ALSO |functions|
6.1 字符串操作:
	nr2char()		通过 ASCII 码值取得一个字符
	char2nr()		取得字符的 ASCII 码值
	str2nr()		把字符串转换为数值
	str2float()		把字符串转换为浮点数
	printf()		根据 % 项目格式化字符串
	escape()		将字符串通过 '\' 转义
	shellescape()		转义字符串用于外壳命令
	fnameescape()		转义 Vim 命令使用的文件名
	tr()			把一组字符翻译成另一组
	strtrans()		将一个字符串变成可显示的格式
	tolower()		将一个字符串转换为小写
	toupper()		将一个字符串转换为大写
	match()			字符串中的模式匹配处
	matchend()		字符串中的模式匹配结束处
	matchstr()		在一个字符串中匹配一个模式
	matchlist()		类似 matchstr(), 同时返回子匹配
	stridx()		子串在母串中第一次出现的地方
	strridx()		子串在母串中最后一次出现的地方
	strlen()		字符串长度
	substitute()		用一个字符串替换一个匹配的模式
	submatch()		取得 ":substitute" 匹配中指定的某个匹配
	strpart()		取得字符串的一部分
	expand()		展开特殊的关键字
	iconv()			转换文本编码格式
	byteidx()		字符串里字符的字节位置
	repeat()		重复字符串多次
	eval()			计算字符串表达式

6.2 列表处理:
	get()			得到项目, 错误索引不报错
	len()			列表的项目总数
	empty()			检查列表是否为空
	insert()		在列表某处插入项目
	add()			在列表后附加项目
	extend()		在列表后附加另一个列表
	remove()		删除列表里一或多个项目
	copy()			建立列表的浅备份
	deepcopy()		建立列表的完整备份
	filter()		删除列表的选定项目
	map()			改变每个列表项目
	sort()			给列表排序
	reverse()		反转列表项目的顺序
	split()			分割字符串成为列表
	join()			合并列表项目成为字符串
	range()			返回数值序列的列表
	string()		列表的字符串表示形式
	call()			调用函数, 参数以列表形式提供
	index()			列表里某值的索引
	max()			列表项目的最大值
	min()			列表项目的最小值
	count()			计算列表里某值的出现次数
	repeat()		重复列表多次

6.3 字典处理:
	get()			得到项目, 错误的键不报错
	len()			字典项目的总数
	has_key()		检查某键是否出现在字典里
	empty()			检查字典是否为空
	remove()		删除字典的项目
	extend()		从一个字典增加项目到另一个字典
	filter()		删除字典的选定项目
	map()			改变每个字典项目
	keys()			得到字典的键列表
	values()		得到字典的值列表
	items()			得到字典的键-值组对的列表
	copy()			建立字典的浅备份
	deepcopy()		建立字典的完整备份
	string()		字典的字符串表示形式
	max()			字典项目的最大值
	min()			字典项目的最小值
	count()			计算字典里某值的出现次数

6.4 浮点数计算:
	float2nr()		把浮点数转换为数值
	abs()			绝对值 (也适用于数值)
	round()			四舍五入
	ceil()			向上取整
	floor()			乡下取整
	trunc()			删除小数点后的值
	log10()			以 10 为底的对数
	pow()			x 的 y 次方
	sqrt()			平方根
	sin()			正弦
	cos()			余弦
	atan()			反正切

6.5 变量:
	type()			变量的类型
	islocked()		检查变量是否加锁
	function()		得到函数名对应的函数引用
	getbufvar()		取得指定缓冲区中的变量值
	setbufvar()		设定指定缓冲区中的变量值
	getwinvar()		取得指定窗口的变量值
	gettabwinvar()		取得指定窗口和标签页的变量值
	setwinvar()		设定指定窗口的变量值
	settabwinvar()		设定指定窗口和标签页的变量值
	garbagecollect()	可能情况下释放内存

6.6 光标和位置标记位置:
	col()			光标或位置标记所在的列
	virtcol()		光标或位置标记所在的屏幕列
	line()			光标或位置标记所在行
	wincol()		光标所在窗口列
	winline()		光标所在窗口行
	cursor()		置光标于 行/列 处
	getpos()		得到光标,位置标记等的位置
	setpos()		设置光标,位置标记等的位置
	byte2line()		取得某字节位置所在行号
	line2byte()		取得某行之前的字节数
	diff_filler()		得到一行之上的填充行数目

6.7 操作当前缓冲区的文本:
	getline()		从缓冲区中取一行
	setline()		替换缓冲区中的一行
	append()		附加行或行的列表到缓冲区
	indent()		某行的缩进
	cindent()		根据 C 缩进法则的某行的缩进
	lispindent()		根据 Lisp 缩进法则的某行的缩进
	nextnonblank()		查找下一个非空白行
	prevnonblank()		查找前一个非空白行
	search()		查找模式的匹配
	searchpos()		寻找模式的匹配
	searchpair()		查找 start/skip/end 配对的另一端
	searchpairpos()		查找 start/skip/end 配对的另一端
	searchdecl()		查找名字的声明

6.8 系统调用及文件操作:
	glob()			展开通配符
	globpath()		在几个路径中展开通配符
	findfile()		在目录列表里查找文件
	finddir()		在目录列表里查找目录
	resolve()		找到一个快捷方式所指
	fnamemodify()		改变文件名
	pathshorten()		缩短路径里的目录名
	simplify()		简化路径, 不改变其含义
	executable()		检查一个可执行程序是否存在
	filereadable()		检查一个文件可读与否
	filewritable()		检查一个文件可写与否
	getfperm()		得到文件权限
	getftype()		得到文件类型
	isdirectory()		检查一个目录是否存在
	getfsize()		取得文件大小
	getcwd()		取得当前工作路径
	haslocaldir()		检查当前窗口是否使用过 |:lcd|
	tempname()		取得一个临时文件的名称
	mkdir()			建立新目录
	delete()		删除文件
	rename()		重命名文件
	system()		取得一个 shell 命令的结果
	hostname()		系统的名称
	readfile()		读入文件到一个行列表
	writefile()		把一个行列表写到文件里

6.9 日期和时间:
	getftime()		得到文件的最近修改时间
	localtime()		得到以秒计的当前时间
	strftime()		把时间转换为字符串
	reltime()		得到准确的当前或者已经经过的时间
	reltimestr()		把 reltime() 的结果转换为字符串

6.10 缓冲区 窗口及参数列表:
	argc()			参数列表项数
	argidx()		参数列表中的当前位置
	argv()			从参数列表中取得一项
	bufexists()		检查缓冲区是否存在
	buflisted()		检查缓冲区是否存在并在列表内
	bufloaded()		检查缓冲区是否存在并已加载
	bufname()		取得某缓冲区名
	bufnr()			取得某缓冲区号
	tabpagebuflist()	得到标签页里的缓冲区列表
	tabpagenr()		得到标签页号
	tabpagewinnr()		类似于特定标签页里的 winnr()
	winnr()			取得当前窗口的窗口号
	bufwinnr()		取得某缓冲区的窗口号
	winbufnr()		取得某窗口的缓冲区号
	getbufline()		得到指定缓冲区的行列表

6.11 命令行:
	getcmdline()		得到当前命令行
	getcmdpos()		得到命令行里的光标位置
	setcmdpos()		设置命令行里的光标位置
	getcmdtype()		得到当前命令行的类型

6.12 quickfix 和位置列表:
	getqflist()		quickfix 错误的列表
	setqflist()		修改 quickfix 列表
	getloclist()		位置列表项目的列表
	setloclist()		修改位置列表

6.13 插入模式补全:
	complete()		设定要寻找的匹配
	complete_add()		加入要寻找的匹配
	complete_check()	检查补全是否被中止
	pumvisible()		检查弹出菜单是否显示

6.14 折叠:
	foldclosed()		检查某一行是否被折叠起来
	foldclosedend()		类似 foldclosed() 但同时返回最后一行
	foldlevel()		检查某行的折叠级别
	foldtext()		产生折叠关闭时所显示的行
	foldtextresult()	得到关闭折叠显示的文本

6.15 语法和高亮:
	clearmatches()		清除 |matchadd()| 和 |:match| 诸命令定义的所有
				匹配
	getmatches()		得到 |matchadd()| 和 |:match| 诸命令定义的所有
				匹配
	hlexists()		检查高亮组是否存在
	hlID()			取得高亮组标示
	synID()			取得某位置的语法标示
	synIDattr()		取得某语法标示的特定属性
	synIDtrans()		取得翻译后的语法标示
	diff_hlID()		得到 diff 模式某个位置的高亮标示
	matchadd()		定义要高亮的模式 (一个 "匹配")
	matcharg()		得到 |:match| 参数的相关信息
	matchdelete()		删除 |matchadd()| 或 |:match| 诸命令定义的匹配
	setmatches()		恢复 |getmatches()| 保存的匹配列表

6.16 拼写:
	spellbadword()		定位光标所在或之后的错误拼写的单词
	spellsuggest()		返回建议的拼写校正列表
	soundfold()		返回 "发音相似" 的单词等价形式

6.17 历史记录:
	histadd()		在历史记录中加入一项
	histdel()		从历史记录中删除一项
	histget()		从历史记录中提取一项
	histnr()		取得某历史记录的最大索引号

6.18 交互:
	browse()		显示文件查找器
	browsedir()		显示目录查找器
	confirm()		让用户作出选择
	getchar()		从用户那里取得一个字符输入
	getcharmod()		取得最近键入字符的修饰符
	feedkeys()		把字符放到预输入队列中
	input()			从用户那里取得一行输入
	inputlist()		让用户从列表里选择一个项目
	inputsecret()		从用户那里取得一行输入, 不回显
	inputdialog()		从用户那里取得一行输入, 使用对话框
	inputsave()		保存和清除预输入 (typeahead)
	inputrestore()		恢复预输入 (译注: 参阅 input())

6.19 GUI:
	getfontname()		得到当前使用的字体名
	getwinposx()		GUI Vim 窗口的 X 位置
	getwinposy()		GUI Vim 窗口的 Y 位置

6.20 Vim 服务器:
	serverlist()		返回服务器列表
	remote_send()		向 Vim 服务器发送字符命令
	remote_expr()		在 Vim 服务器内对一个表达式求值
	server2client()		向一个服务器客户发送应答
	remote_peek()		检查一个服务器是否已经应答
	remote_read()		从一个服务器读取应答
	foreground()		将一个 Vim 窗口移至前台
	remote_foreground()	将一个 Vim 服务器窗口移至前台

6.21 窗口大小和位置:
	winheight()		取得某窗口的高度
	winwidth()		取得某窗口的宽度
	winrestcmd()		恢复窗口大小的返回命令
	winsaveview()		得到当前窗口的视图
	winrestview()		恢复保存的当前窗口的视图

6.22 杂项:
	mode()			取得当前编辑状态
	visualmode()		最近一次使用过的可视模式
	hasmapto()		检查映射是否存在
	mapcheck()		检查匹配的映射是否存在
	maparg()		取得映射的右部 (rhs)
	exists()		检查变量, 函数等是否存在
	has()			检查 Vim 是否支持某特性
	changenr()		返回最近的改变号
	cscope_connection()	检查有无与 cscope 的连接
	did_filetype()		检查某文件类型自动命令是否已经使用
	eventhandler()		检查是否在一个事件处理程序内
	getpid()		得到 Vim 的进程号

	libcall()		调用一个外部库函数
	libcallnr()		同上, 但返回一个数值

	getreg()		取得寄存器内容
	getregtype()		取得寄存器类型
	setreg()		设定寄存器内容及类型

	taglist()		得到匹配标签的列表
	tagfiles()		得到标签文件的列表
	

7. 定义一个函数
7.1 定义一个函数
	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
NOTE:
函数名必须以大写字母开始.

7.2 范围的使用
7.2.1 方式一
|&
	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum <= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction
&|
你可以这样调用上面的函数:
|&
	:10,30call Count_words()
&|
这个函数将被调用一次并显示字数.

7.2.2 方式二
   另一种使用范围的方式是在定义函数时不给出 "range" 关键字. Vim 将把光标移动到
范围内的每一行, 并分别对该行调用此函数. 例如: >
|&
	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction
&|
如果你用下面的方式调用该函数: >
|&
	:10,15call Number()
&|
它将被执行六次.

7.3 可 变 参 数
Vim 允许你定义参数个数可变的函数. 下面的例子给出一个至少有一个参数 (start), 但
可以多达 20 个附加参数的函数:
	:function Show(start, ...)

NOTE:
    变量 "a:1" 表示第一个可选的参数, "a:2" 表示第二个, 如此类推. 变量 "a:0" 表
示这些参数的个数.
    例如下面的例子: "a:1" 为 "1", ...
    你可以用 a:000 变量, 它是所有 "..." 参数的列表. SEE ALSO |a:000|.
|&
	:function! Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:  echo a:000
	:endfunction
	:call Show(0, 1, 2 , 3)
&|

7.4 函 数 清 单
	":function" 命令列出所有用户自定义的函数及其参数:
	如果要查看该函数具体做什么, 用该函数名作为 ":function" 命令的参数即可:
	:function AddBkFileLists

7.5 调 试
SEE ALSO |debug-scripts|


7.6 删 除 函 数
为了删除 Show() 函数: 
	:delfunction Show
如果该函数不存在, 你会得到一个错误信息. 

7.7 函 数 引 用
有时使变量指向一个或另一个函数可能有用. 要这么做, 用 function() 函数. 它把函数
名转换为引用: 
|&
	:let result = 0		" 或 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
&|

NOTE 保存函数引用的变量名必须用大写字母开头, 不然和内建函数的名字会引起混淆. 
   调用变量指向的函数可以用 call() 函数. 它的第一个参数是函数引用, 第二个参数
是参数构成的列表. 


8. 列表和字典

8.1 列表
列表是事物的有序序列. 这里的事物包括各种类型的值. 所以你可以建立数值列表,列表
列表甚至混合项目的列表. 要建立包含三个字符串的列表: 
	:let alist = ['aap', 'mies', 'noot']
列表项目用方括号包围, 逗号分割. 要建立空列表: 
	:let alist = []

用 add() 函数可以为列表加入项目: >

	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
<	['foo', 'bar'] ~

列表的连接用 + 完成: >

	:echo alist + ['foo', 'bar']
<	['foo', 'bar', 'foo', 'bar'] ~

或者, 你可以直接扩展一个列表: >

	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
<	['one', 'two', 'three'] ~

注意 这里如果用 add(), 效果不一样: >

	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
<	['one', ['two', 'three']] ~

add() 的第二个参数作为单个项目被加入. 


FOR 循 环

使用列表的一个好处是可以在上面进行叠代: >

	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
<	one ~
	two ~
	three ~

这段代码循环遍历列表 "alist" 的每个项目, 分别把它们的值赋给变量 "n". for 循环
通用的形式是: >

	:for {varname} in {listexpression}
	:  {commands}
	:endfor

要循环若干次, 你需要长度为给定次数的列表. range() 函数建立这样的列表: >

	:for a in range(3)
	:  echo a
	:endfor
<	0 ~
	1 ~
	2 ~

注意 range() 产生的列表的第一个项目为零, 而最后一个项目比列表的长度小一. 
   你也可以指定最大值,步进, 反向也可以: >

	:for a in range(8, 4, -2)
	:  echo a
	:endfor
<	8 ~
	6 ~
	4 ~

更有用的示例, 循环遍历缓冲区的所有行: >

	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor

察看行 1 到 20 (包含), 并回显那里找到的任何日期. 


字 典

字典保存键-值组对. 如果知道键, 你可以快速查找值. 字典用花括号形式建立: >

	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

现在你可以把键放在方括号里以查找单词: >

	:echo uk2nl['two']
<	twee ~

字典定义的通用形式是: >

	{<key> : <value>, ...}

空字典是不包含任何键的字典: >

	{}

字典的用途很多. 它可用的函数也不少. 例如, 你可以得到它的键列表并在其上循环: >

	:for key in keys(uk2nl)
	:  echo key
	:endfor
<	three ~
	one ~
	two ~

注意 这些键没有排序. 你自己可以对返回列表按照特定顺序进行排序: >

	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
<	one ~
	three ~
	two ~

但你永远不能得到项目定义时的顺序. 为此目的, 只能用列表. 列表里的项目被作为有序
序列保存. 


字 典 函 数

字典项目通常可以用方括号里的索引得到: >

	:echo uk2nl['one']
<	een ~

完成同样操作且无需那么多标点符号的方法: >

	:echo uk2nl.one
<	een ~

这只能用于由 ASCII 字母,数位和下划线组成的键. 此方式也可以用于赋值: >

	:let uk2nl.four = 'vier'
	:echo uk2nl
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~

现在来一些特别的: 你可以直接定义函数并把它的引用放在字典里: >

	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction

让我们先试试: >

	:echo uk2nl.translate('three two five one')
<	drie twee ??? een ~

你注意到的第一个特殊之处是 ":function" 一行最后的 "dict". 这标记该函数为某个字
典使用. "self" 局部变量这时可以引用该字典. 
   现在把这个复杂的 return 命令拆开: >

	split(a:line)

split() 函数接受字符串, 把它分成空白分隔的多个单词, 并返回这些单词组成的列表. 
所以下例返回的是: >

	:echo split('three two five one')
<	['three', 'two', 'five', 'one'] ~

map() 函数的第一个参数是上面这个列表. 它然后遍历列表, 用它的第二个参数来进行计
算, 过程中 "v:val" 设为每个项目的值. 这相当于 for 循环的快捷方式. 命令: >

	:let alist = map(split(a:line), 'get(self, v:val, "???")')

等价于: >

	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor

get() 函数检查某键是否在字典里存在. 如果是, 提取它对应的键. 如果不是, 返回缺省
值, 此例中缺省值是 '???'. 此函数可以很方便地处理键不一定存在而你不想要错误信息
的情形. 

join() 函数和 split() 刚好相反: 它合并列表里的单词, 中间放上空格. 
  split(),map() 和 join() 的组合非常简洁地对单词组成的行进行过滤. 


面 向 对 象 编 程

现在你可以把值和函数都放进字典里, 实际上, 字典已经可以作为对象来使用. 
   上面我们用了一个字典来把荷兰语翻译为英语. 我们可能也想为其他的语言作同样的
事. 让我们先建立一个对象 (也就是字典), 它支持 translate 函数, 但没有要翻译的单
词表: >

	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction

和上面的函数稍有不同, 这里用 'self.words' 来查找单词的翻译, 但我们还没有
self.words. 所以你可以把这叫做抽象类. 

让我们现在实例化一个荷兰语的翻译对象: >

	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
<	drie een ~

然后来一个德语的翻译器: >

	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
<	drei ein ~

你看到 copy() 函数被用来建立 "transdict" 字典的备份, 然后修改此备份以加入单词
表. 当然, 原来的字典还是保持原样. 

现在你可以再进一步, 使用你偏好的翻译器: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
<	een twee drie ~

这里 "trans" 指向两个对象 (字典) 之一, 并不涉及到备份的建立. 关于列表和字典同
一性的更多说明可见 |list-identity| 和 |dict-identity|. 

你使用的语言现在可能还不支持. 你可以覆盖 translate() 函数, 让它什么都不做: >

	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
<	three one wladiwostok ~

注意 使用 ! 会覆盖已有的函数引用. 现在, 在没找到能够识别的语言的时候, 让我们用
"uk2uk": >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
<	one two three ~

进一步的阅读可见 |Lists| 和 |Dictionaries|. 

==============================================================================

